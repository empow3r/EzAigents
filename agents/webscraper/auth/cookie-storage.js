const fs = require('fs').promises;
const path = require('path');
const crypto = require('crypto');

class CookieStorage {
  constructor() {
    this.cookiesDir = path.join(process.cwd(), '.agent-memory', 'webscraper', 'cookies');
    this.algorithm = 'aes-256-gcm';
    this.secretKey = this.getOrCreateSecretKey();
  }

  getOrCreateSecretKey() {
    const keyPath = path.join(this.cookiesDir, '..', '.cookie-key');
    try {
      return require('fs').readFileSync(keyPath, 'utf8');
    } catch (error) {
      const key = crypto.randomBytes(32).toString('hex');
      require('fs').mkdirSync(path.dirname(keyPath), { recursive: true });
      require('fs').writeFileSync(keyPath, key);
      return key;
    }
  }

  async saveCookies(domain, cookies) {
    try {
      await fs.mkdir(this.cookiesDir, { recursive: true });
      
      const cookieData = {
        domain,
        cookies,
        timestamp: new Date().toISOString()
      };
      
      const encrypted = this.encrypt(JSON.stringify(cookieData));
      const cookiePath = path.join(this.cookiesDir, `${domain.replace(/\./g, '_')}.json`);
      
      await fs.writeFile(cookiePath, JSON.stringify(encrypted));
      return true;
    } catch (error) {
      console.error('Failed to save cookies:', error);
      return false;
    }
  }

  async loadCookies(domain) {
    try {
      const cookiePath = path.join(this.cookiesDir, `${domain.replace(/\./g, '_')}.json`);
      const encryptedData = await fs.readFile(cookiePath, 'utf8');
      const encrypted = JSON.parse(encryptedData);
      const decrypted = this.decrypt(encrypted);
      const cookieData = JSON.parse(decrypted);
      
      // Check if cookies are not expired
      const validCookies = cookieData.cookies.filter(cookie => {
        if (!cookie.expires || cookie.expires === -1) return true;
        return new Date(cookie.expires * 1000) > new Date();
      });
      
      return validCookies;
    } catch (error) {
      console.log('No saved cookies found:', error.message);
      return [];
    }
  }

  async clearCookies(domain) {
    try {
      const cookiePath = path.join(this.cookiesDir, `${domain.replace(/\./g, '_')}.json`);
      await fs.unlink(cookiePath);
      return true;
    } catch (error) {
      console.error('Failed to clear cookies:', error);
      return false;
    }
  }

  async getAllDomains() {
    try {
      const files = await fs.readdir(this.cookiesDir);
      return files
        .filter(file => file.endsWith('.json'))
        .map(file => file.replace('.json', '').replace(/_/g, '.'));
    } catch (error) {
      console.error('Failed to get domains:', error);
      return [];
    }
  }

  encrypt(text) {
    const iv = crypto.randomBytes(16);
    const cipher = crypto.createCipheriv(
      this.algorithm,
      Buffer.from(this.secretKey, 'hex'),
      iv
    );
    
    let encrypted = cipher.update(text, 'utf8', 'hex');
    encrypted += cipher.final('hex');
    
    const authTag = cipher.getAuthTag();
    
    return {
      encrypted,
      authTag: authTag.toString('hex'),
      iv: iv.toString('hex')
    };
  }

  decrypt(data) {
    const decipher = crypto.createDecipheriv(
      this.algorithm,
      Buffer.from(this.secretKey, 'hex'),
      Buffer.from(data.iv, 'hex')
    );
    
    decipher.setAuthTag(Buffer.from(data.authTag, 'hex'));
    
    let decrypted = decipher.update(data.encrypted, 'hex', 'utf8');
    decrypted += decipher.final('utf8');
    
    return decrypted;
  }

  // Helper method to merge cookies
  mergeCookies(existingCookies, newCookies) {
    const cookieMap = new Map();
    
    // Add existing cookies
    existingCookies.forEach(cookie => {
      const key = `${cookie.name}-${cookie.domain}-${cookie.path}`;
      cookieMap.set(key, cookie);
    });
    
    // Overwrite with new cookies
    newCookies.forEach(cookie => {
      const key = `${cookie.name}-${cookie.domain}-${cookie.path}`;
      cookieMap.set(key, cookie);
    });
    
    return Array.from(cookieMap.values());
  }

  // Export cookies in Netscape format (compatible with curl, wget, etc.)
  async exportNetscapeFormat(domain) {
    try {
      const cookies = await this.loadCookies(domain);
      let netscapeFormat = '# Netscape HTTP Cookie File\n';
      netscapeFormat += '# This file was generated by Ez Aigent WebScraper\n\n';
      
      cookies.forEach(cookie => {
        const httpOnly = cookie.httpOnly ? 'TRUE' : 'FALSE';
        const secure = cookie.secure ? 'TRUE' : 'FALSE';
        const expires = cookie.expires || 0;
        
        netscapeFormat += [
          cookie.domain,
          'TRUE', // include subdomains
          cookie.path,
          secure,
          expires,
          cookie.name,
          cookie.value
        ].join('\t') + '\n';
      });
      
      return netscapeFormat;
    } catch (error) {
      console.error('Failed to export cookies:', error);
      return null;
    }
  }
}

module.exports = CookieStorage;