#!/usr/bin/env node

/**
 * Enhancement Documentation Generator
 * Automatically generates comprehensive documentation for all enhancements
 */

const fs = require('fs').promises;
const path = require('path');
const Redis = require('ioredis');

const redis = new Redis(process.env.REDIS_URL || 'redis://localhost:6379');

// Documentation templates
const TEMPLATES = {
  overview: `# EzAigents Enhancement Documentation

## Overview

This document provides comprehensive documentation for all implemented enhancements in the EzAigents multi-agent orchestration platform.

**Generated:** {{timestamp}}
**Version:** {{version}}

## Enhancement Summary

{{enhancementSummary}}

---

{{enhancementDetails}}

## Quick Start

### Prerequisites
- Node.js 20+
- Redis server
- Docker (optional)

### Running Enhancements
\`\`\`bash
# Start the entire enhancement system
npm run enhance

# Monitor progress
npm run enhance:monitor

# Check status
npm run enhance:status

# Validate implementations
npm run enhance:validate
\`\`\`

## Architecture

### Enhancement Framework Components
- **Dispatcher**: Routes tasks to appropriate agents
- **Monitor**: Real-time progress tracking
- **Validator**: Quality assurance and testing
- **Workload Balancer**: Intelligent agent selection
- **Reporter**: Comprehensive status reporting

### Agent Specializations
{{agentSpecializations}}

## API Reference

### Enhancement Control
{{apiReference}}

## Troubleshooting

### Common Issues
{{troubleshooting}}

---

*This documentation was automatically generated by the EzAigents Enhancement Documentation Generator.*`,

  enhancement: `## {{enhancementName}}

**Priority:** {{priority}}  
**Status:** {{status}}  
**Progress:** {{progress}}%  
**Assigned Agents:** {{assignedAgents}}

### Description
{{description}}

### Components
{{components}}

### Implementation Status
{{implementationStatus}}

### Usage
{{usage}}

### Configuration
{{configuration}}

### Dependencies
{{dependencies}}

### Testing
{{testing}}

---`
};

class EnhancementDocsGenerator {
  constructor() {
    this.enhancementData = null;
    this.projectRoot = path.join(__dirname, '..');
    this.docsDir = path.join(this.projectRoot, 'docs');
    this.timestamp = new Date().toISOString();
  }

  /**
   * Initialize the documentation generator
   */
  async initialize() {
    // Ensure docs directory exists
    await fs.mkdir(this.docsDir, { recursive: true });
    
    // Load enhancement data
    await this.loadEnhancementData();
    
    console.log('üìö Enhancement Documentation Generator initialized');
  }

  /**
   * Load enhancement configuration and status
   */
  async loadEnhancementData() {
    try {
      const enhancementPath = path.join(this.projectRoot, 'shared', 'enhancement-tasks.json');
      const data = await fs.readFile(enhancementPath, 'utf-8');
      this.enhancementData = JSON.parse(data);
    } catch (error) {
      console.error('Failed to load enhancement data:', error);
      throw error;
    }
  }

  /**
   * Get enhancement status from Redis
   */
  async getEnhancementStatus(enhancementId) {
    try {
      const status = await redis.hget('enhancement:status', enhancementId) || 'not-started';
      const progress = await redis.hget('enhancement:progress', enhancementId) || '0';
      
      return {
        status,
        progress: parseInt(progress)
      };
    } catch (error) {
      return { status: 'unknown', progress: 0 };
    }
  }

  /**
   * Analyze implementation status of files
   */
  async analyzeImplementationStatus(enhancement) {
    const status = {
      total: enhancement.tasks.length,
      completed: 0,
      inProgress: 0,
      pending: 0,
      files: []
    };

    for (const task of enhancement.tasks) {
      const filePath = path.join(this.projectRoot, task.file);
      let fileStatus = 'pending';
      let fileSize = 0;
      let lastModified = null;

      try {
        const stats = await fs.stat(filePath);
        fileSize = stats.size;
        lastModified = stats.mtime;
        
        if (fileSize > 0) {
          fileStatus = 'completed';
          status.completed++;
        } else {
          fileStatus = 'in-progress';
          status.inProgress++;
        }
      } catch (error) {
        status.pending++;
      }

      status.files.push({
        file: task.file,
        agent: task.agent,
        status: fileStatus,
        size: fileSize,
        lastModified
      });
    }

    return status;
  }

  /**
   * Generate agent specializations documentation
   */
  generateAgentSpecializations() {
    const agents = {
      'Claude': {
        specializations: ['Architecture', 'Refactoring', 'Complex Logic', 'Security'],
        description: 'Excels at architectural design and complex reasoning tasks'
      },
      'GPT-4': {
        specializations: ['Backend Logic', 'API Development', 'Integration'],
        description: 'Optimized for backend services and API implementations'
      },
      'DeepSeek': {
        specializations: ['Testing', 'Validation', 'Infrastructure'],
        description: 'Focused on testing frameworks and infrastructure code'
      },
      'Mistral': {
        specializations: ['Documentation', 'Configuration', 'DevOps'],
        description: 'Specialized in documentation and configuration management'
      },
      'Gemini': {
        specializations: ['Analysis', 'Optimization', 'Performance'],
        description: 'Expert in code analysis and performance optimization'
      }
    };

    let docs = '';
    for (const [agent, info] of Object.entries(agents)) {
      docs += `### ${agent}\n`;
      docs += `**Specializations:** ${info.specializations.join(', ')}\n`;
      docs += `**Description:** ${info.description}\n\n`;
    }

    return docs;
  }

  /**
   * Generate API reference documentation
   */
  generateApiReference() {
    const endpoints = [
      {
        method: 'POST',
        endpoint: '/api/enhancements/dispatch',
        description: 'Dispatch enhancement tasks to agents',
        params: '{ enhancementId: string, priority?: string }'
      },
      {
        method: 'GET',
        endpoint: '/api/enhancement-status',
        description: 'Get current enhancement status',
        params: 'None'
      },
      {
        method: 'GET',
        endpoint: '/api/enhancement-progress',
        description: 'Get detailed progress information',
        params: 'enhancementId?: string'
      },
      {
        method: 'POST',
        endpoint: '/api/enhancements/validate',
        description: 'Validate enhancement implementation',
        params: '{ enhancementId: string }'
      }
    ];

    let docs = '';
    for (const endpoint of endpoints) {
      docs += `#### \`${endpoint.method} ${endpoint.endpoint}\`\n`;
      docs += `${endpoint.description}\n\n`;
      docs += `**Parameters:** \`${endpoint.params}\`\n\n`;
    }

    return docs;
  }

  /**
   * Generate troubleshooting documentation
   */
  generateTroubleshooting() {
    const issues = [
      {
        issue: 'Enhancement tasks not dispatching',
        solution: 'Check Redis connection and agent status. Ensure agents are running with `./check-agents.sh`'
      },
      {
        issue: 'Low task completion rate',
        solution: 'Use workload balancer to redistribute tasks: `npm run enhance:balance`'
      },
      {
        issue: 'Agent overload warnings',
        solution: 'Scale agents or adjust concurrency limits in agent configuration'
      },
      {
        issue: 'Validation failures',
        solution: 'Review validation report and fix code quality issues before proceeding'
      },
      {
        issue: 'Dashboard not showing progress',
        solution: 'Verify API endpoints are accessible and Redis contains enhancement data'
      }
    ];

    let docs = '';
    for (const item of issues) {
      docs += `### ${item.issue}\n`;
      docs += `**Solution:** ${item.solution}\n\n`;
    }

    return docs;
  }

  /**
   * Generate individual enhancement documentation
   */
  async generateEnhancementDoc(enhancementId, enhancement) {
    const redisStatus = await this.getEnhancementStatus(enhancementId);
    const implementationStatus = await this.analyzeImplementationStatus(enhancement);
    
    // Generate components list
    let components = '';
    for (const task of enhancement.tasks) {
      const fileInfo = implementationStatus.files.find(f => f.file === task.file);
      const statusIcon = fileInfo.status === 'completed' ? '‚úÖ' : 
                        fileInfo.status === 'in-progress' ? 'üîÑ' : '‚è≥';
      
      components += `- ${statusIcon} **${path.basename(task.file)}** (${task.agent})\n`;
      components += `  - Path: \`${task.file}\`\n`;
      if (fileInfo.lastModified) {
        components += `  - Last Modified: ${fileInfo.lastModified.toISOString()}\n`;
      }
      components += '\n';
    }

    // Generate usage examples
    const usage = `\`\`\`bash
# Dispatch this enhancement
npm run enhance:dispatch ${enhancementId}

# Monitor progress
npm run enhance:monitor

# Validate implementation
npm run enhance:validate ${enhancementId}
\`\`\``;

    // Generate testing commands
    const testing = `\`\`\`bash
# Run specific tests for this enhancement
npm run enhance:test ${enhancementId}

# Run integration tests
npm run test:integration

# Check code quality
npm run lint
\`\`\``;

    // Fill template
    let doc = TEMPLATES.enhancement
      .replace('{{enhancementName}}', enhancement.title)
      .replace('{{priority}}', enhancement.priority)
      .replace('{{status}}', redisStatus.status)
      .replace('{{progress}}', redisStatus.progress)
      .replace('{{assignedAgents}}', enhancement.assigned_agents.join(', '))
      .replace('{{description}}', this.getEnhancementDescription(enhancementId))
      .replace('{{components}}', components)
      .replace('{{implementationStatus}}', this.formatImplementationStatus(implementationStatus))
      .replace('{{usage}}', usage)
      .replace('{{configuration}}', this.getEnhancementConfiguration(enhancementId))
      .replace('{{dependencies}}', this.getEnhancementDependencies(enhancement))
      .replace('{{testing}}', testing);

    return doc;
  }

  /**
   * Get enhancement description
   */
  getEnhancementDescription(enhancementId) {
    const descriptions = {
      'security-layer': 'Implements enterprise-grade security with HashiCorp Vault for secrets management, OAuth2/OIDC authentication, Role-Based Access Control (RBAC), and end-to-end encryption for agent communications.',
      'observability-stack': 'Provides comprehensive system observability with OpenTelemetry distributed tracing, Prometheus metrics collection, structured logging, and Grafana dashboards for monitoring.',
      'distributed-queue-system': 'Replaces simple Redis queuing with a robust distributed queue system supporting Kafka and RabbitMQ backends, with automatic failover and load balancing.',
      'intelligent-orchestration': 'Implements ML-powered task orchestration with DAG-based execution, intelligent agent selection, cost optimization, and dynamic workflow management.',
      'collaboration-framework': 'Enables advanced agent collaboration through consensus protocols, shared knowledge graphs, task negotiation, and conflict resolution mechanisms.',
      'self-healing-infrastructure': 'Creates autonomous infrastructure with Kubernetes operators, health monitoring, circuit breakers, auto-scaling, and predictive failure detection.'
    };

    return descriptions[enhancementId] || 'Enhancement description not available.';
  }

  /**
   * Format implementation status
   */
  formatImplementationStatus(status) {
    const progressBar = '‚ñà'.repeat(Math.floor(status.completed / status.total * 20)) + 
                       '‚ñë'.repeat(20 - Math.floor(status.completed / status.total * 20));
    
    return `**Progress:** [${progressBar}] ${status.completed}/${status.total} files completed

- ‚úÖ **Completed:** ${status.completed} files
- üîÑ **In Progress:** ${status.inProgress} files  
- ‚è≥ **Pending:** ${status.pending} files`;
  }

  /**
   * Get enhancement configuration
   */
  getEnhancementConfiguration(enhancementId) {
    const configs = {
      'security-layer': `\`\`\`bash
# Configure Vault
export VAULT_ADDR=http://localhost:8200
export VAULT_TOKEN=your-vault-token

# Configure OAuth2
export OAUTH_CLIENT_ID=your-client-id
export OAUTH_CLIENT_SECRET=your-client-secret
\`\`\``,
      'observability-stack': `\`\`\`yaml
# Prometheus configuration
global:
  scrape_interval: 15s
  
scrape_configs:
  - job_name: 'ezaigents'
    static_configs:
      - targets: ['localhost:3000']
\`\`\``,
      'distributed-queue-system': `\`\`\`json
{
  "primary": "kafka",
  "fallback": "redis",
  "kafka": {
    "brokers": ["localhost:9092"],
    "clientId": "ezaigents"
  }
}
\`\`\``,
      'intelligent-orchestration': `\`\`\`json
{
  "mlModel": "agent-selector-v1",
  "costOptimization": true,
  "maxConcurrency": 10
}
\`\`\``
    };

    return configs[enhancementId] || 'No specific configuration required.';
  }

  /**
   * Get enhancement dependencies
   */
  getEnhancementDependencies(enhancement) {
    let deps = '### NPM Dependencies\n';
    
    // Common dependencies based on file types
    const fileDeps = {
      'vault-client.js': ['node-vault', 'axios'],
      'auth-service.js': ['jsonwebtoken', 'passport', 'bcrypt'],
      'telemetry.js': ['@opentelemetry/api', '@opentelemetry/sdk-node'],
      'metrics-collector.js': ['prom-client'],
      'queue-manager.js': ['ioredis', 'kafkajs', 'amqplib'],
      'orchestration-engine.js': ['@tensorflow/tfjs-node', 'graphlib'],
      'health-checker.js': ['@kubernetes/client-node']
    };

    const allDeps = new Set();
    for (const task of enhancement.tasks) {
      const fileName = path.basename(task.file);
      const deps = fileDeps[fileName] || [];
      deps.forEach(dep => allDeps.add(dep));
    }

    if (allDeps.size > 0) {
      deps += '```bash\n';
      deps += 'npm install ' + Array.from(allDeps).join(' ') + '\n';
      deps += '```\n\n';
    }

    deps += '### System Dependencies\n';
    deps += '- Redis server\n';
    deps += '- Node.js 20+\n';
    
    if (enhancement.files_to_create?.some(f => f.includes('kafka'))) {
      deps += '- Apache Kafka (optional)\n';
    }
    
    if (enhancement.files_to_create?.some(f => f.includes('rabbitmq'))) {
      deps += '- RabbitMQ (optional)\n';
    }

    return deps;
  }

  /**
   * Generate complete documentation
   */
  async generateDocumentation() {
    console.log('üìù Generating enhancement documentation...');

    // Generate individual enhancement docs
    let enhancementDetails = '';
    let enhancementSummary = '| Enhancement | Priority | Status | Progress |\n';
    enhancementSummary += '|-------------|----------|--------|-----------|\n';

    for (const [enhancementId, enhancement] of Object.entries(this.enhancementData.enhancements)) {
      const redisStatus = await this.getEnhancementStatus(enhancementId);
      const implementationStatus = await this.analyzeImplementationStatus(enhancement);
      const completionPercent = Math.round((implementationStatus.completed / implementationStatus.total) * 100);

      // Add to summary table
      enhancementSummary += `| ${enhancement.title} | ${enhancement.priority} | ${redisStatus.status} | ${completionPercent}% |\n`;

      // Generate detailed documentation
      const enhancementDoc = await this.generateEnhancementDoc(enhancementId, enhancement);
      enhancementDetails += enhancementDoc;

      // Save individual enhancement docs
      const enhancementDocPath = path.join(this.docsDir, `enhancement-${enhancementId}.md`);
      await fs.writeFile(enhancementDocPath, enhancementDoc);
      console.log(`  ‚úì Generated ${enhancementId} documentation`);
    }

    // Generate main overview document
    const overviewDoc = TEMPLATES.overview
      .replace('{{timestamp}}', this.timestamp)
      .replace('{{version}}', '1.0.0')
      .replace('{{enhancementSummary}}', enhancementSummary)
      .replace('{{enhancementDetails}}', enhancementDetails)
      .replace('{{agentSpecializations}}', this.generateAgentSpecializations())
      .replace('{{apiReference}}', this.generateApiReference())
      .replace('{{troubleshooting}}', this.generateTroubleshooting());

    // Save main documentation
    const overviewPath = path.join(this.docsDir, 'ENHANCEMENTS.md');
    await fs.writeFile(overviewPath, overviewDoc);

    // Generate README for docs directory
    const readmePath = path.join(this.docsDir, 'README.md');
    const readmeContent = `# EzAigents Documentation

This directory contains automatically generated documentation for all system enhancements.

## Files

- **ENHANCEMENTS.md** - Complete enhancement overview and documentation
- **enhancement-*.md** - Individual enhancement documentation

## Regenerating Documentation

\`\`\`bash
# Regenerate all documentation
node cli/enhancement-docs-generator.js generate

# Generate specific enhancement docs
node cli/enhancement-docs-generator.js generate security-layer
\`\`\`

## Last Generated

${this.timestamp}
`;

    await fs.writeFile(readmePath, readmeContent);

    console.log('‚úÖ Documentation generation complete!');
    console.log(`üìö Main documentation: ${overviewPath}`);
    console.log(`üìÅ Documentation directory: ${this.docsDir}`);

    return {
      overviewPath,
      docsDir: this.docsDir,
      enhancementCount: Object.keys(this.enhancementData.enhancements).length
    };
  }

  /**
   * CLI interface
   */
  async handleCLI() {
    const command = process.argv[2];
    const enhancementId = process.argv[3];

    switch (command) {
      case 'generate':
        if (enhancementId) {
          // Generate specific enhancement doc
          if (this.enhancementData.enhancements[enhancementId]) {
            const enhancement = this.enhancementData.enhancements[enhancementId];
            const doc = await this.generateEnhancementDoc(enhancementId, enhancement);
            const docPath = path.join(this.docsDir, `enhancement-${enhancementId}.md`);
            await fs.writeFile(docPath, doc);
            console.log(`‚úÖ Generated documentation for ${enhancementId}: ${docPath}`);
          } else {
            console.error(`‚ùå Enhancement ${enhancementId} not found`);
            process.exit(1);
          }
        } else {
          // Generate all documentation
          const result = await this.generateDocumentation();
          console.log(`\nüìä Generated documentation for ${result.enhancementCount} enhancements`);
        }
        break;

      case 'list':
        console.log('Available enhancements:');
        for (const [id, enhancement] of Object.entries(this.enhancementData.enhancements)) {
          console.log(`  - ${id}: ${enhancement.title}`);
        }
        break;

      case 'clean':
        // Clean documentation directory
        try {
          const files = await fs.readdir(this.docsDir);
          for (const file of files) {
            if (file.endsWith('.md')) {
              await fs.unlink(path.join(this.docsDir, file));
            }
          }
          console.log('‚úÖ Documentation directory cleaned');
        } catch (error) {
          console.error('Error cleaning docs:', error.message);
        }
        break;

      default:
        console.log('EzAigents Enhancement Documentation Generator');
        console.log('\nCommands:');
        console.log('  generate [enhancement-id]  - Generate documentation (all or specific)');
        console.log('  list                       - List available enhancements');
        console.log('  clean                      - Clean documentation directory');
        console.log('\nExamples:');
        console.log('  node enhancement-docs-generator.js generate');
        console.log('  node enhancement-docs-generator.js generate security-layer');
    }
  }
}

// Main execution
async function main() {
  const generator = new EnhancementDocsGenerator();
  
  try {
    await generator.initialize();
    await generator.handleCLI();
  } catch (error) {
    console.error('Error:', error.message);
    process.exit(1);
  } finally {
    redis.disconnect();
  }
}

// Run if called directly
if (require.main === module) {
  main();
}

module.exports = EnhancementDocsGenerator;